# 流畅的Python 阅读笔记

## 第一部分：序幕
### 第1章：	Python数据模型
1.1	一摞Python风格的纸牌
	使用collection中的namedtuuple来构建FrenchDeck
	三个方法：__init__，__getitem__，__len__
	__getitem__可以实现迭代
	__contains__，如果没有，in会遍历
1.2	如何使用特殊方法
	很多时候调用特殊方法是隐式的。比如for...in...就是调用iter(x)，背后则是x.__iter__()
	不要随意添加特殊方法
	1.2.1	模拟数值类型
		__repr__ __abs__  __add__  __mul__ __bool__
	1.2.2	字符串表示形式
		__repr__和__str__的区别
	1.2.3	算数运算符
		+和*这两个方法通过__add__和__mul__实现
	1.2.4	自定义的布尔值
		bool背后调用__bool__方法，如果不存在会尝试调用__len__()，为0返回False，不然返回True
1.3	特殊方法一览
	P11
1.4	为什么len不是普通方法
	Cpython会直接从一个C结构体里读取对象操作（后门）
1.5	本章小结
1.6	延伸阅读


## 第二部分：数据结构
### 第2章：	序列构成的数组
2.1	内置序列类型概览
	容器序列/扁平序列
	可变序列/不可变序列
2.2	列表推导和生成器表达式
	2.2.1	列表推导和可读性
	[表达式 for 迭代变量 in 可迭代对象 [if 条件表达式] ]
	2.2.2	列表推导同fliter和map的比较
		list(filter(筛选条件表达式，迭代变量））
	2.2.3	笛卡儿积
	[表达式 for 迭代变量 in 可迭代对象 for 迭代变量 in 可迭代对象]		
	2.2.4	生成器表达式
	(表达式 for 迭代变量 in 可迭代对象 [if 条件表达式] )
2.3	元祖不仅仅是不可变的列表
	2.3.1	元组和记录
		信息和位置是捆绑的
	2.3.2	元组拆包
		x,y = (x,y)
		x,y = *(x,y)
		_ 占位符
		*args来获取不确定数量的参数	
		平行赋值 a,b,*rest,c=range(5)， 0,1,[2,3],4
	2.3.3	嵌套元组拆包
		a,b,(c,d)=(a,b,(c,d))
	2.3.4	具名元组
		collections.namedtuple('类名','各字段名')
		字段名可以是带空格的字符串，或者由数个字符串组成的可迭代对象
		._fields
		._make()
		._asdict()
	2.3.5	作为不可变列表的元组
2.4	切片
	2.4.1	为什么切片和区间会忽略最后一个元素
	2.4.2	对对象进行切片
		seq[start:stop:step]
		调用seq.__getitem__(slice(start,stop,step))
	2.4.3	多维切片和省略
		Python内置的序列类型都是一维的
		省略 ...
	2.4.4	给切片赋值
		如果赋值的对象是一个切片，赋值语句的右侧必须是一个可迭代对象
		并不一定赋值可迭代对象中的元素个数一样
2.5	对序列使用+和*
2.6	序列的增量赋值
2.7	list.sort方法和内置函数sorted
2.8	用bisect来管理已排序的序列
	2.8.1	用bisect来搜索
	2.8.2	用bisect.insort插入新元素
2.9	当列表不是首选时
	2.9.1	数组
	2.9.2	内存视图
	2.9.3	Numpy和Scipy
	2.9.4	双向队列和其他形式的队列
2.10	本章小结
2.11	延伸阅读

### 第3章：	字典和集合
3.1	泛映射类型
3.2	字典推导
3.3	常见的映射方法
3.4	映射的弹性键查询
	3.4.1	defaultdict： 处理找不到的键的一个选择
	3.4.2	特殊方法 __missing__
3.5	字典的变种
3.6	子类化UserDict
3.7	不可变映射类型
3.8	集合论
	3.8.1	集合字面量
	3.8.2	集合推导
	3.8.3	集合的操作
3.9	dict和set的背后
	3.9.1	一个关于效率的实验
	3.9.2	字典中的散列表
	3.9.3	dict的实现及其导致的结果
	3.9.4	set的实现以及推导结果
3.10	本章小结
3.11	延伸阅读
