# 流畅的Python 阅读笔记

## 第一部分：序幕

### 第1章：	Python数据模型

#### 	1.1	一摞Python风格的纸牌

​		使用collection中的namedtuuple来构建FrenchDeck

​		三个方法：__init__，__getitem__，__len__

​		__getitem__可以实现迭代

​		__contains__，如果没有，in会遍历

#### 	1.2	如何使用特殊方法

​			很多时候调用特殊方法是隐式的。比如for...in...就是调用iter(x)，背后则是x.__iter__()

​			不要随意添加特殊方法

​				1.2.1	模拟数值类型	

​					__repr__ __abs__  __add__  __mul__ __bool__

​				1.2.2	字符串表示形式

​					__repr__和__str__的区别

​				1.2.3	算数运算符
​					+和*这两个方法通过__add__和__mul__实现

​				1.2.4	自定义的布尔值

​					bool背后调用__bool__方法，如果不存在会尝试调用__len__()，为0返回False，不然返回True

#### 	1.3	特殊方法一览

​			P11
#### 1.4	为什么len不是普通方法

​			Cpython会直接从一个C结构体里读取对象操作（后门）
#### 1.5	本章小结

#### 1.6	延伸阅读



## 第二部分：数据结构

### 第2章：	序列构成的数组

####	2.1	内置序列类型概览

​	容器序列/扁平序列

​	可变序列/不可变序列

####	2.2	列表推导和生成器表达式

​	2.2.1	列表推导和可读性

​	[表达式 for 迭代变量 in 可迭代对象 [if 条件表达式] ]

​	2.2.2	列表推导同fliter和map的比较

​		list(filter(筛选条件表达式，迭代变量））

​	2.2.3	笛卡儿积

​	[表达式 for 迭代变量 in 可迭代对象 for 迭代变量 in 可迭代对象]		

​	2.2.4	生成器表达式

​	(表达式 for 迭代变量 in 可迭代对象 [if 条件表达式] )

####	2.3	元祖不仅仅是不可变的列表

​	2.3.1	元组和记录

​		信息和位置是捆绑的

​	2.3.2	元组拆包

​		x,y = (x,y)

​		x,y = *(x,y)

​		_ 占位符

​		*args来获取不确定数量的参数	*

​		平行赋值 a,b,*rest,c=range(5)， 0,1,[2,3],4*

​	2.3.3	嵌套元组拆包

​		a,b,(c,d)=(a,b,(c,d))

​	2.3.4	具名元组

​		collections.namedtuple('类名','各字段名')

​		字段名可以是带空格的字符串，或者由数个字符串组成的可迭代对象

​		._fields_
​		._make()_
​		._asdict()
​	2.3.5	作为不可变列表的元组

####	2.4	切片
​	2.4.1	为什么切片和区间会忽略最后一个元素

​	2.4.2	对对象进行切片

​		seq[start:stop:step]

​		调用seq.__getitem__(slice(start,stop,step))

​	2.4.3	多维切片和省略

​		Python内置的序列类型都是一维的

​		省略 ...

​	2.4.4	给切片赋值

​		如果赋值的对象是一个切片，赋值语句的右侧必须是一个可迭代对象

​		并不一定赋值可迭代对象中的元素个数一样

####	2.5	对序列使用+和*

​	+和*的操作都不修改原有的操作对象，而是构建一个全新的序列

####	2.6	序列的增量赋值

​	优先__iadd__（用于就地加法，如果没有会选择add方法，这时类似a=a+b（得到新对象，赋值给a）

​	不要把可变对象放在元组中，增量赋值不是原子操作

#### 2.7	list.sort方法和内置函数sorted

​	list.sort回在元列表上操作

​	sorted会有新的列表返回

####	2.8	用bisect来管理已排序的序列

​	2.8.1	用bisect来搜索

​		参数是一个有序列表和一个值，返回插入位置

​	2.8.2	用bisect.insort插入新元素

​		参数是一个升序列表和一个值，插入后保持升序不变

#### 2.9	当列表不是首选时

​	2.9.1	数组

​		array.array('类型',生成器)，只包含数字

​		支持方法：pop，insert，extend，frombytes，tofile

​		不再支持list.sort排序，排序需要使用array.array(a.typecode,sorted(a))

​	2.9.2	内存视图

​		cast方法，以不同的类型来读取内存中的一段数据

​	2.9.3	Numpy和Scipy

​		两个重要的科学库

​	2.9.4	双向队列和其他形式的队列

​		双向队列collections.deque(生成器，maxlen参数)

​			rotate，appendleft，extend，extendleft

####	2.10	本章小结

####	2.11	延伸阅读



###	第3章：字典和集合

####	3.1	泛映射类型

​	collections.abc中的Mapping和MutableMapping是dict和其他类似的类型的超类

​	dict是abc.Mapping的子类

​	可散列的数据类型定义

​		实现hash方法和eq方法。元组只有在所有元素都是可散列的时候本身才可散列

####	3.2	字典推导
​		{key:value for.....}

####	3.3	常见的映射方法
​		copy是浅复制

​		使用setdefault(key,[default])来处理找不到的键

####	3.4	映射的弹性键查询

​	3.4.1	defaultdict： 处理找不到的键的一个选择

​		collections.defaultdict(迭代对象)来构建字典

​	3.4.2	特殊方法 __missing__

​		missing方法只会被getitem调用

​		自定义映射类的时候适合继承collections.UserDict类

​		isinstance方法确认实例是不是属于这个类

####	3.5	字典的变种

​		collections.OrderDict：添加键的时候保持顺序

​		collections.ChainMap：可以容纳数个不同的映射对象，查找时会被作为一个整体查找

​		collections.Counter： 键的每次更新都会有计数器

​			update,mostcommon方法

​		collections.UserDict：标准dict的纯python版本，用来作为用户继承写子类

####	3.6	子类化UserDict

​		使用UserDict能避免dict中的部分捷径导致的子类需要重写

​		UserDict不是dict的子类，但其中的data部分是dict的实例

####	3.7	不可变映射类型

​		types.MappingProxyType：镜像一个字典，不能对这个镜像进行任何修改。修改元字典的结果会反馈到这个镜像字典上

####	3.8	集合论

​	可以去重，集合中元素必须可以散列。

​	set本身是不可散列的，但frozenset可以

​	中缀运算符

​	3.8.1	集合字面量

​		{元素,[元素]}，空集合必须表示为set()

​		frozenset没有特殊字面量句法，必须使用构造方法

​	3.8.2	集合推导

​		{元素 for...}

​	3.8.3	集合的操作

​		中缀操作符需要两个都是集合，但其他的方法只要求传入的参数是可迭代对象

​		a.union(b,c,d)
####	3.9	dict和set的背后

​	3.9.1	一个关于效率的实验

​		不管查询多少个元素的字典或者集合，所耗费的时间都可以忽略不计

​	3.9.2	字典中的散列表

​		散列表是稀疏数组，每个键值对都占用一个元表，包含对键和值的两个引用

​		相等性，加盐操作和散列表算法

​	3.9.3	dict的实现及其导致的结果

​		键必须可以散列

​		内存开销大

​		键查询很快

​		键的次序取决于添加顺序（键值相同时）

​		添加新值可能改变顺序（因为可能扩容）

​	3.9.4	set的实现以及推导结果

​		set和frozenset也是依赖散列表，只有一个值的引用

####	3.10	本章小结

####	3.11	延伸阅读



###		第4章：文本和字节序列

####	4.1	字符问题

​	decode，encode

​	bytes以'b'开头

####	4.2	字节概要

​	bytes或者bytearry对象的各个元素都是0-255之间的数

​	每个字符可能含有1个或者多个字节

​	bytes切片返回的是切片字节，而bytes返回一个元素的话是256以内的整数

​	字节值可能会以三种方式转换

​		可打印ASCII范围的字节，使用字节自身

​		制表符，换行符，回车符和\对应使用转义

​		其他字节的值，使用十六进制转义序列

​	结构体和内存视图

​		struct模块提供一些函数看，把打包的字节序列转换成不同类型字段组成的元组，话有一些函数用于执行反向转换

​			struct.unpack(fmt,header)

​			header是利用memoryview读出的一段值

####	4.3	基本的编码器

####	4.4	了解解码问题

​	4.4.1	处理UnicodeEncodeError

​		文本转为字节序列时目标编码中没有定义字符，抛出异常

​	4.4.2	处理UnicodeDecodeError

​		二进制转文本时，遇到无法转换的字节，抛出异常

​	4.4.3	使用预期之外的编码加载模块时抛出的SyntaxError

​		python3 默认utf-8

​	4.4.4	如何找出字节序列的编码

​		命令行文件 chardetect 文件名

​	4.4.5	BOM：有用的鬼符

​		UTF-16中的\xff\xfe就是BOM，字节序标记。指明编码时使用IntelCpu的小字节序列

####	4.5	处理文本文件

​	三明治法。尽早将输入的二进制文件转为字符串，最后将字符串转为二进制。业务中不要编码和解码

####	4.6	为了正确比较而规范化Unicode字符串

​	unicodedata.normalize(参数,str)

​		NFC

​		NFD

​		NFKD

​		NFKC

​	4.6.1	大小写折叠

​		str.casefold() 基本等同于str.lower()

​	4.6.2	规范化文本匹配使用函数

​	4.6.3	极端“规范化”：去掉变音符号

####	4.7	Unicode文本排序
​	非ASCII文本的标准排序方式是使用locale.strxfrm函数

​		locale.setlocale设定比较代码

​		locale.strxfrm作为key的比较函数

​	使用pyuca.Collator.sort_key方法

####	4.8	Unicode数据库

####	4.9	支持字符串和字节序列的双模式API

​	4.9.1	正则表达式中字符串和字节序列

​		字节构成的正则表达式只能匹配ASCII字符

​		字符串模式可以匹配Unicode数字或者字母

​	4.9.2	os函数中的字符串和字节序列

####	4.10	本章小结

####	4.11	延伸阅读



##	第三部分：把函数视视作对象

###	第5章： 一等函数

​	一等对象定义：

​		在运行时创建

​		能赋值给变量或数据结构中的元素

​		能作为参数传给函数

​		能作为函数的返回结果

​	python中所有函数都是一等对象

####	5.1	把函数视作对象

​	函数有属性，可以赋值给变量，也可以作为函数的参数

####	5.2	高阶函数

​	接受函数为参数，或者把函数作为结果返回的函数是高阶函数

​	map，fliter和functools.reduce三个函数

​	all，any两个归约函数

####	5.3	匿名函数

​	lambda

​	lambda函数的定义体中不能赋值，也不能使用while和try等语句

​	lambda只是语法糖，和def语句一样，会创建函数对象

####	5.4	可调用对象

​	通过callable()判断是否可以调用

​	7种可以调用的对象

​		用户定义的函数

​		内置函数

​		内置方法

​		方法

​		类

​		类的实例

​		生成器函数

####	5.5	用户定义的可调用类型

​	任何python对象都可以通过实现__call__方法来实现实例调用

####	5.6	函数内省

​	使用dir函数可以探知函数属性

####	5.7	从定位参数到仅限关键字参数

​	定义函数时若想指定仅限关键字参数，要把它们放到前面有**的*参数后面。

​	如果不想支持数量不定的定位参数，但想支持仅限关键字参数，在签名中放一个*

####	5.8	获取关于参数的信息

​	函数的—__defaults__属性保存定位参数和关键字参数的默认值

​	仅限关键字参数的默认值在__kwdefaults__中

​	inspect.signature()探查属性

​	bind把一个个参绑定到签名中的形参上

####	5.9	函数注解
​	可以在各个参数的：之后增加注解表达式，放在参数名和=号之间。

####	5.10	支持函数式编程的包

​	5.10.1	operator模块

​		operator.itemgetter

​		operator.attrgetter

​		operator.methodcaller

​	5.10.2	使用functools.partial冻结参数

​		基于一个函数创建一个新的调用对象，把原函数的某些参数固定

####	5.11	本章小结
####	5.12	延伸阅读



###	第6章： 使用一等函数实现设计模式

####	6.1	案例分析： 重构“策略”模式
​	6.1.1	经典的“策略”模式

​		策略：抽象基类

​	6.1.2	使用函数实现“策略”模式

​		没有策略，通过函数实现

​	6.1.3	选择最佳策略；简单的方式

​	6.1.4	找出模块中的全部策略

####	6.2	“命令”模式
####	6.3	本章小结

####	6.4	延伸阅读



###	第7章： 函数装饰器和闭包

​	用于在源码中“标记”函数，以某种方式增强函数行为

####	7.1	装饰器基础知识

​	装饰器可以调用的对象，其参数是另一个函数（被装饰的函数）。装饰器可能处理被装饰函数，然后把它返回，或将其替换成另一个函数或可调用对象

####	7.2	Python何时执行装饰器

​	装饰器在被装饰的函数定义之后立刻执行，通常是在导入时（加载模块时）

​	被装饰的函数只在调用时才执行

####	7.3	使用装饰器改进“策略”模式

####	7.4	变量作用域规则

​	Python不要求声明变量，但是假定在函数定义体中赋值的变量是局部变量

####	7.5	闭包

​	闭包指延伸了作用域的函数，其中包含函数定义体中引用、但是补在定义体中定义的非全局变量。

####	7.6	nonlocal声明

​	把变量标记为自由变量，即使在函数中为变量赋予新值，也会变成自由变量

####	7.7	实现一个简单的装饰器

​	functools.wraps装饰器可以把相关的属性从func复制到clocked中

####	7.8	标准库中的装饰器

​	7.8.1	使用functools.lru_cache做备忘

​		调用方法@functools.lru_cache()，可以有参数maxsize和typed

​		装饰器可以叠放

​	7.8.2	单分派泛函数

​		可以把多个函数绑在一起组成一个泛函数

####	7.9	叠放装饰器

####	7.10	参数化装饰器

​	7.10.1	一个参数化的注册装饰器

​		两层函数，最外层带参数，第二层是真正的装饰器

​	7.10.2	参数化clock装饰器



##	第四部分：面向对象惯用法

### 第8章：对象引用、可变性和垃圾回收

####	8.1	变量不是盒子

####	8.2	标识、相等性和别名

​	8.2.1	在==和is之间选择

​	8.2.2	元组的相对不可变性

####	8.3	默认做浅复制

####	8.4	函数的参数作为引用时

​	8.4.1	不要使用可变类型作为参数的默认值

​	8.4.2	防御可变参数

####	8.5	del和垃圾回收

####	8.6	弱引用

​	8.6.1	WeakValueDictionary简介

​	8.6.2	弱引用的局限

####	8.7	Python对不可变类型施加的把戏

####	8.8 本章小结

####	8.9	延伸阅读



###	第9章：符合Python风格的对象

####	9.1	对象表示形式

####	9.2	再谈向量类

####	9.3	备选与构造方法

####	9.4	classmethod与staticmethod

####	9.5	格式化显式

####	9.6	可散列的Vector2d

####	9.7	Python的私有属性和“受保护的“属性

####	9.8	使用__slots__类属性节省空间

####	9.9 	覆盖类属性

####	9.10	本章小结

#### 9.11	延伸阅读



###	第10章：序列的修改、散列和切片

####	10.1 Vector类：用户定义的序列类型

####	10.2	Vector类第一版：与Vector2d类兼容

####	10.3	协议和鸭子类型

#### 10.4	Vector类第2版：可切片的序列

​	10.4.1	切片原理

​	10.4.2	能处理切片的getitem方法

####	10.5	Vector类第3版：动态存取属性

#### 10.6	Vector类第4版：散列和快速等值测试

####	10.7	Vector类第5版：格式化

####	10.8	本章小结

#### 10.9	延伸阅读



###	第11章：接口，从协议到抽象类

####	11.1	Python文化中的接口和协议

####	11.2	Python喜欢序列

####	11.3	使用猴子补丁在运行时实现协议

####	11.4	Alex Martelli的水禽

#### 11.5	定义抽象基类的子类

####	11.6	标准库中的抽象基类

​	11.6.1	collections.abc 模块中的抽象基类

​	11.6.2	抽象基类的数字塔

####	11.7	定义并使用一个抽象基类

​	11.7.1	抽象基类句法详解

​	11.7.2	定义Tombola抽象基类的子类

​	11.7.3	Tombola的虚拟子类

####	11.8	Tombola子类的测试方式

####	11.9	Python使用register的方式

####	11.10	鹅的行为有可能像鸭子

####	11.11	本章小结

####	11.12	延伸阅读



### 第12章：继承的优缺点

####	12.1	子类化内置类型很麻烦

####	12.2	多重继承和方法解析顺序

####	12.3	多重继承的真实运用

####	12.4	处理多重继承

####	12.5	一个现代示例：Django通过视图中的混入

####	12.6	本章小结

####	12.7	延伸阅读



###	第13章：正确重载运算符

####	13.1	运算符重载基础

####	13.2	一元运算符

####	13.3	重载向量加法运算符+

####	13.4	重载标量乘法运算符*

#### 13.5	众多比较运算符

####	13.6	增量赋值运算符

####	13.7 本章小结

####	13.8 延伸阅读









