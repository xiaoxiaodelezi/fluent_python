# 流畅的Python 阅读笔记

## 第一部分：序幕

### 第1章：	Python数据模型

#### 	1.1	一摞Python风格的纸牌

​		使用collection中的namedtuuple来构建FrenchDeck

​		三个方法：__init__，__getitem__，__len__

​		__getitem__可以实现迭代

​		__contains__，如果没有，in会遍历

#### 	1.2	如何使用特殊方法

​			很多时候调用特殊方法是隐式的。比如for...in...就是调用iter(x)，背后则是x.__iter__()

​			不要随意添加特殊方法

​				1.2.1	模拟数值类型	

​					__repr__ __abs__  __add__  __mul__ __bool__

​				1.2.2	字符串表示形式

​					__repr__和__str__的区别

​				1.2.3	算数运算符
​					+和*这两个方法通过__add__和__mul__实现

​				1.2.4	自定义的布尔值

​					bool背后调用__bool__方法，如果不存在会尝试调用__len__()，为0返回False，不然返回True

#### 	1.3	特殊方法一览

​			P11
#### 1.4	为什么len不是普通方法

​			Cpython会直接从一个C结构体里读取对象操作（后门）
#### 1.5	本章小结

#### 1.6	延伸阅读



## 第二部分：数据结构

### 第2章：	序列构成的数组

####	2.1	内置序列类型概览

​	容器序列/扁平序列

​	可变序列/不可变序列

####	2.2	列表推导和生成器表达式

​	2.2.1	列表推导和可读性

​	[表达式 for 迭代变量 in 可迭代对象 [if 条件表达式] ]

​	2.2.2	列表推导同fliter和map的比较

​		list(filter(筛选条件表达式，迭代变量））

​	2.2.3	笛卡儿积

​	[表达式 for 迭代变量 in 可迭代对象 for 迭代变量 in 可迭代对象]		

​	2.2.4	生成器表达式

​	(表达式 for 迭代变量 in 可迭代对象 [if 条件表达式] )

####	2.3	元祖不仅仅是不可变的列表

​	2.3.1	元组和记录

​		信息和位置是捆绑的

​	2.3.2	元组拆包

​		x,y = (x,y)

​		x,y = *(x,y)

​		_ 占位符

​		*args来获取不确定数量的参数	*

​		平行赋值 a,b,*rest,c=range(5)， 0,1,[2,3],4*

​	2.3.3	嵌套元组拆包

​		a,b,(c,d)=(a,b,(c,d))

​	2.3.4	具名元组

​		collections.namedtuple('类名','各字段名')

​		字段名可以是带空格的字符串，或者由数个字符串组成的可迭代对象

​		._fields_
​		._make()_
​		._asdict()
​	2.3.5	作为不可变列表的元组

####	2.4	切片
​	2.4.1	为什么切片和区间会忽略最后一个元素

​	2.4.2	对对象进行切片

​		seq[start:stop:step]

​		调用seq.__getitem__(slice(start,stop,step))

​	2.4.3	多维切片和省略

​		Python内置的序列类型都是一维的

​		省略 ...

​	2.4.4	给切片赋值

​		如果赋值的对象是一个切片，赋值语句的右侧必须是一个可迭代对象

​		并不一定赋值可迭代对象中的元素个数一样

####	2.5	对序列使用+和*

​	+和*的操作都不修改原有的操作对象，而是构建一个全新的序列

####	2.6	序列的增量赋值

​	优先__iadd__（用于就地加法，如果没有会选择add方法，这时类似a=a+b（得到新对象，赋值给a）

​	不要把可变对象放在元组中，增量赋值不是原子操作

#### 2.7	list.sort方法和内置函数sorted

​	list.sort回在元列表上操作

​	sorted会有新的列表返回

####	2.8	用bisect来管理已排序的序列

​	2.8.1	用bisect来搜索

​		参数是一个有序列表和一个值，返回插入位置

​	2.8.2	用bisect.insort插入新元素

​		参数是一个升序列表和一个值，插入后保持升序不变

#### 2.9	当列表不是首选时

​	2.9.1	数组

​		array.array('类型',生成器)，只包含数字

​		支持方法：pop，insert，extend，frombytes，tofile

​		不再支持list.sort排序，排序需要使用array.array(a.typecode,sorted(a))

​	2.9.2	内存视图

​		cast方法，以不同的类型来读取内存中的一段数据

​	2.9.3	Numpy和Scipy

​		两个重要的科学库

​	2.9.4	双向队列和其他形式的队列

​		双向队列collections.deque(生成器，maxlen参数)

​			rotate，appendleft，extend，extendleft

####	2.10	本章小结

####	2.11	延伸阅读



###	第3章：字典和集合

####	3.1	泛映射类型

​	collections.abc中的Mapping和MutableMapping是dict和其他类似的类型的超类

​	dict是abc.Mapping的子类

​	可散列的数据类型定义

​		实现hash方法和eq方法。元组只有在所有元素都是可散列的时候本身才可散列

####	3.2	字典推导
​		{key:value for.....}

####	3.3	常见的映射方法
​		copy是浅复制

​		使用setdefault(key,[default])来处理找不到的键

####	3.4	映射的弹性键查询

​	3.4.1	defaultdict： 处理找不到的键的一个选择

​		collections.defaultdict(迭代对象)来构建字典

​	3.4.2	特殊方法 __missing__

​		missing方法只会被getitem调用

​		自定义映射类的时候适合继承collections.UserDict类

​		isinstance方法确认实例是不是属于这个类

####	3.5	字典的变种

​		collections.OrderDict：添加键的时候保持顺序

​		collections.ChainMap：可以容纳数个不同的映射对象，查找时会被作为一个整体查找

​		collections.Counter： 键的每次更新都会有计数器

​			update,mostcommon方法

​		collections.UserDict：标准dict的纯python版本，用来作为用户继承写子类

####	3.6	子类化UserDict

​		使用UserDict能避免dict中的部分捷径导致的子类需要重写

​		UserDict不是dict的子类，但其中的data部分是dict的实例

####	3.7	不可变映射类型

​		types.MappingProxyType：镜像一个字典，不能对这个镜像进行任何修改。修改元字典的结果会反馈到这个镜像字典上

####	3.8	集合论

​	可以去重，集合中元素必须可以散列。

​	set本身是不可散列的，但frozenset可以

​	中缀运算符

​	3.8.1	集合字面量

​		{元素,[元素]}，空集合必须表示为set()

​		frozenset没有特殊字面量句法，必须使用构造方法

​	3.8.2	集合推导

​		{元素 for...}

​	3.8.3	集合的操作

​		中缀操作符需要两个都是集合，但其他的方法只要求传入的参数是可迭代对象

​		a.union(b,c,d)
####	3.9	dict和set的背后

​	3.9.1	一个关于效率的实验

​		不管查询多少个元素的字典或者集合，所耗费的时间都可以忽略不计

​	3.9.2	字典中的散列表

​		散列表是稀疏数组，每个键值对都占用一个元表，包含对键和值的两个引用

​		相等性，加盐操作和散列表算法

​	3.9.3	dict的实现及其导致的结果

​		键必须可以散列

​		内存开销大

​		键查询很快

​		键的次序取决于添加顺序（键值相同时）

​		添加新值可能改变顺序（因为可能扩容）

​	3.9.4	set的实现以及推导结果

​		set和frozenset也是依赖散列表，只有一个值的引用

####	3.10	本章小结

####	3.11	延伸阅读



###		第4章：文本和字节序列

####	4.1	字符问题

​	decode，encode

​	bytes以'b'开头

####	4.2	字节概要

​	bytes或者bytearry对象的各个元素都是0-255之间的数

​	每个字符可能含有1个或者多个字节

​	bytes切片返回的是切片字节，而bytes返回一个元素的话是256以内的整数

​	字节值可能会以三种方式转换

​		可打印ASCII范围的字节，使用字节自身

​		制表符，换行符，回车符和\对应使用转义

​		其他字节的值，使用十六进制转义序列

​	结构体和内存视图

​		struct模块提供一些函数看，把打包的字节序列转换成不同类型字段组成的元组，话有一些函数用于执行反向转换

​			struct.unpack(fmt,header)

​			header是利用memoryview读出的一段值

####	4.3	基本的编码器

####	4.4	了解解码问题

​	4.4.1	处理UnicodeEncodeError

​		文本转为字节序列时目标编码中没有定义字符，抛出异常

​	4.4.2	处理UnicodeDecodeError

​		二进制转文本时，遇到无法转换的字节，抛出异常

​	4.4.3	使用预期之外的编码加载模块时抛出的SyntaxError

​		python3 默认utf-8

​	4.4.4	如何找出字节序列的编码

​		命令行文件 chardetect 文件名

​	4.4.5	BOM：有用的鬼符

​		UTF-16中的\xff\xfe就是BOM，字节序标记。指明编码时使用IntelCpu的小字节序列

####	4.5	处理文本文件

​	三明治法。尽早将输入的二进制文件转为字符串，最后将字符串转为二进制。业务中不要编码和解码

####	4.6	为了正确比较而规范化Unicode字符串

​	unicodedata.normalize(参数,str)

​		NFC

​		NFD

​		NFKD

​		NFKC

​	4.6.1	大小写折叠

​		str.casefold() 基本等同于str.lower()

​	4.6.2	规范化文本匹配使用函数

​	4.6.3	极端“规范化”：去掉变音符号

####	4.7	Unicode文本排序
​	非ASCII文本的标准排序方式是使用locale.strxfrm函数

​		locale.setlocale设定比较代码

​		locale.strxfrm作为key的比较函数

​	使用pyuca.Collator.sort_key方法

####	4.8	Unicode数据库

####	4.9	支持字符串和字节序列的双模式API

​	4.9.1	正则表达式中字符串和字节序列

​		字节构成的正则表达式只能匹配ASCII字符

​		字符串模式可以匹配Unicode数字或者字母

​	4.9.2	os函数中的字符串和字节序列

####	4.10	本章小结

####	4.11	延伸阅读

