# 流畅的Python



## 第一章：Python数据模型

1.1	一摞Python风格的纸牌

1.2	一个简单的二维向量类 



### 本章总结：

介绍了一些特殊方法

getitem,len,contains,iter,repr,abs,add,mulstr,bool



## 第二章：序列构成的数组

### 列表推导和可读性

2.1	把一个字符串编程Unicode码位的列表

2.2	把一个字符串编程Unicode码位的列表（列表推导）

2.3	用列表推导和map/filter组合来创建同样表单

2.4	使用列表推导计算笛卡尔乘积

2.5	用生成器表达初始化元组和数组

2.6	使用生成器表达式计算笛卡尔积



### 元组

2.7	把元组用作记录

2.8	用嵌套元组来获取经度

2.9	定义和使用具名元组

2.10	具名元组的属性和方法



### 切片

2.11	纯文本文件形式的收据以一行字符串的形式被解析

2.12 	一个包含3个列表的列表，嵌套的3个列表各自有3个元素模仿一个井字游戏

2.13	含有3个指向同一对象的引用的列表毫无用处



### 序列的增量赋值

2.14	一个谜题

2.15	没人料到的结果：t[2]被改动，但也有异常

2.16	s[a] +=  b 背后的字节代码



### 用bisect来管理已排序的序列

2.17	在有序序列中使用bisect查找某个元素的插入位置

2.18	根据一个分数，找到它所对应的成绩

2.19	insort可以保持有序序列的顺序



### 数组

2.20	一个浮点型数组的创建、存入文件和从文件读取的过程

2.21	通过改变数组中的一个字节来更新数组里某个元素的值

2.22	对numpy.ndarray的行和列进行基本操作



### 双向队列和其他形式的队列

2.23	使用双向队列



### 本章总结：

序列可以分为可变和不可变，或者扁平序列和容器序列

列表推导和生成器

元组（拆包，*句法）

具名元组（._asdict()方法）

增量赋值

sort和sorted

bisect

array.array

numpy,scipy





## 第三章： 字典和集合

### 字典推导

3.1	字典推导的运用



### 常见的映射方法

3.2	从索引中获取单词出现的频率信息，并把它们写进对应的列表里

3.3	3_2.py的输出结果

3.4	用一行就解决了获取和更新单次的出现情况列表，用到了dict.setdefault



### 映射的弹性键查询

3.5	利用defaultdic实例而不是setdefault方法，创建一个从单次到其出现情况的映射

3.6	当有非字符串的键被查找的时候，如果在该键不存在的情况下，把它转换为字符串的

3.7	在查询的时候把非字符串的键转换为字符串



### 子类化UserDict

3.8	无论是添加、更新还是查询操作，StrKeyDict都会把非字符串的键转换为字符串



### 不可变映射类型

3.9	用MappingProxyType 来获取字典的只读实例mappingproxy



### 集合论

3.10	needles 的元素再haystack里出现的次数，两个变量都是set

3.11	needles的元素在haystack里出现的次数（迭代）

3.12	needles的元素在haystack里出现的次数（迭代），两个对象可以是任意迭代对象



### 集合推导

3.13	新建一个Latin-1字符集合，该集合里的每个字符的Unicode名字里都有"SIGN"这个单词



### 关于效率的实验

3.14	在haystack里用迭代的方法查找needles的元素，并计算找到的元素的个数

3.15	利用交集来计算needles中出现在haystack中的元素的个数



### 字典中的散列表

3.16	几个数字的散列值的二进制对比

3.17	将同样的数据以不同的顺序添加到3个字典里

3.18	3.17中输出的3个字典的结果顺序是不一样的



### 本章总结

标准库提供的一些映射类型

defaultdict,OrderDict,ChianMap,Count

两个强大方法：setdefault,update

通过__missing__来定义找不到对象时的操作

colletions.abc模块中提供Mapping 和 MutableMapping两个基类

types中MappingProxyType创建不可变映射对象

Set 和MutableSet 两个抽象基本类

dict和set的散列概念





## 第四章：文本和字节序列

### 字符问题

4.1	编码和解码



### 字节概要

4.2	包含5个字节的bytes和bytearray对象

4.3	使用数组中的原始数据初始化bytes对象

4.4	使用memoryview和struct查看一个GIF图像的首部



### 基本的编码器

4.5	使用3个编译器编码字符串"El Niño"，得到的字节序列差异很大



### 处理UnicodeEncodeError

4.6	编码成字节序列：成功和错误的处理



### 处理UnicodeDecodeError

4.7	把字节序列解码成字符串：成功和错误处理



### 使用预期之外的编码加载模块时抛出的SyntaxError

4.8	"你好，世界"的葡萄牙语版本



### 处理文本文件

4.9	一个平台上的编码问题（可能发生，也可能不发生）

4.10	细分析在windows中运行的示例4_9，找出并修正问题



### 编码默认值

4.11	探索编码的默认值

4.12	4_11在不同windows版本中的表现



### 规范化文本匹配使用函数

4.13	比较规范化Unicode 字符串



### 极端“规范化”

4_14	去掉全部组合记号的函数

4_15	4_14中函数的实例

4_16	删除拉丁字母中组合记号的函数

4_17	把一些西文印刷字符转换成ASCII字符

4_18	4_17中的实例



### Unicode文本排序

4.19	使用locale.strxfrm函数做排序键

4.20	使用pyuca.collator.sort_key方法



### Unicode数据库

4.21	Unicode数据库中数值字符的元数据示例



### 正则表达式中的字符串和字节序列

4.22	比较简单的字符串正则表达式和字节序列正则表达式的行为



### os函数中的字符串和字节序列

4.23	把字符串和字节序列参数传给listdir函数得到的结果

4.24	使用surrogateescape 错误处理方式



### 本章总结

区别字符和字节

bytes，bytearray，memoryview

Chardet包

设置合理的编码

locale来排序

PyUCA包





## 第五章：一等函数

### 把函数视作对象

5.1	建并测试一个函数，然后读取它的__doc__属性，再检查它的类型

5.2	通过函数的别名使用函数，再把函数作为参数传递



### 高阶函数

5.3	根据单次长度给一个列表排序

5.4	根据反向拼写给一个单词列表排序



### map、filter和reduce的现代替代品

5.5	计算阶乘列表：map和filter与列表推导比较

5.6	使用reduce和sum计算0-99的和



### 匿名函数

5.7	使用lambda表达式反转拼写，然后依次给单次列表排序



### 用户定义的可调用类型

5.8	调用BingoCage实例，从打乱的列表中取出一个元素



### 函数内省

5.9	列出常规对象没有而函数有的属性



### 从定位参数到只限关键字参数

5.10	# tag函数用于生成HTML标签，使用名为cls的关键字参数传入“class”属性,这是一种变通方法，因为“class”是Python的关键字

5.11	tag函数的调用示例



### 获取关于参数的信息

5.12	Bobo知道hello需要person参数，并且从HTTP请求中获取它

5.13	如果请求中缺少参数，Bobo返回403 forbidden响应

5.14	传入所需要的person参数才能得到OK响应

5.15	在指定长度附近截断字符串的函数

5.16	提取关于函数参数的信息

5.17	提取函数的签名

5.18	把tag函数的签名绑定到一个参数字典上



### 函数注解

5.19	有注解的clip函数

5.20	从函数签名中提取注解



### operator模块

5.21	使用reduce函数和一个匿名函数计算阶乘

5.22	使用reduce和operator.mul函数计算阶乘

5.23	演示使用itemgetter排序一个元组列表

5.24	定义一个nametuple，名为metro_data，用attrgetter来处理它

5.25	methodcaller使用示例



### 使用functools.partial冻结参数

5.26	使用partia把一两个参数函数改编成需要单参数的可调用对象

5.27	用partial 构建一个便利的Unicode规范化函数

5.28	把partial应用到tag函数上



### 本章小结

探讨函数的一等本性

Python的7种可调用对象

inspect模块

functools.partial函数





## 使用一等函数实现设计模式

### 经典的策略模式

6.1	实现Order类，支持插入式折扣策略

6.2	使用不同促销折扣的Order类示例

6.3	Order类和使用函数实现的折扣策略

6.4	使用函数实现的促销折扣的Order类示例

6.5	函数计算所有折扣，并返回额度最大的

6.6	迭代一个函数列表，并找出折扣度最大的

6.7	内省模块的全局命名空间，构建promos列表

6.8	内省单独的promotions模块，构建promos列表



### “命令”模式

6.9	MacroCommand的各个实例都在内部存储着命令列表



### 本章总结

三种设计的策略

1.经典策略（类）：为方法构筑一个类

2.使用函数实现策略：方法直接绑定在对象上

3.“命令”模式策略：给命令做个合集调用





## 第七章：函数装饰器和闭包

### 装饰器的基本知识

7.1	装饰器通常把函数替换成另一个函数



### Python何时执行装饰器

7.2	registration模块



### 使用装饰器改进“策略”模式

7.3	promos列表中的值使用promotion装饰器填充



### 变量作用域规则

7.4	一个函数，读取一个局部变量和全局变量

7.5	b是局部变量，因为函数在定义中给他赋值了

7.6	反汇编示例7-4的f1函数

7.7	反汇编示例7-5中的f2函数



### 闭包

7.8	计算平均值的类

7.9	计算移动平均值的高阶函数

7.10	计算移动平均值的高阶函数

7.11	审查make_averager创建的函数

7.12	接续示例7-11



### nonlocal 声明

7.13	计算移动平均值的高阶函数，不保存所有历史数据，但是有缺陷

7.14	计算移动平均值的高阶函数，不保存所有历史数据，使用nonlocal修正



### 实现一个简单的装饰器

7.15	一个简单的装饰器，输出函数的运行时间

7.16	使用clock装饰器



### 工作原理

7.17	改进后的clock装饰器



### 使用functools.lru_cache做备忘

7.18	生成第n个斐波那契数，递归方式非常耗时

7.19	使用缓存实现，速度更快



### 单分派泛函数

7.20	生成HTML的htmlize函数，调整几种输出对象的输出

7.21	singledispact创建一个自定义的htmlize.register装饰器，把多个函数绑在一起组成一个泛函数



### 参数化装饰器

7.22	7_2的删减版



### 一个参数化的注册装饰器

7.23	为了接受参数，新的register装饰器必须作为函数调用

7.24	使用7_23的程序



### 参数化clock装饰器

7.25	参数化clock装饰器

7.26	demo1

7.27	demo2



### 本章小结

从一个没有内部函数的装饰器到有两层嵌套的装饰器

functools.wraps

functools.lru_cache

functools.singledispatch





## 第八章：对象引用、可变性和垃圾回收

### 变量不是盒子

8.1	变量a和变量b引用同一个列表，而不是那个列表的副本

8.2	创建对象以后才会把变量分配给对象



### 标识、相等性和别名

8.3	charles和lewis指代同一个对象

8.4	alex与charles比较的结果是相等，但alex不是charles



### 元组的相对不可变性

8.5	一开始，t1和t2相等，但是修改t1中的一个人可变元素后，两者就不想等了



### 默认做浅复制

8.6	为一个包含另一个列表的列表做浅复制

8.7	8.6的输出结果



### 为任意对象做深复制和浅复制

8.8	校车乘客在途中上车和下车

8.9	使用copy和deepcopy产生的影响

8.10	循环引用：b引用a，然后追加到a中，deepcopy会想办法复制a



### 函数的参数作为引用时

8.11	函数可能会修改接收到的任何可变对象



### 不要使用可变类型作为参数的默认值

8.12	一个简单的类，说明可变默认变量的危险

8.13	备受幽灵乘客折磨的校车



### 防御可变参数

8.14	从TwilightBus下车后，乘客消失不见了

8.15	一个简单的类，说明接受可变参数的风险



### del和垃圾回收

8.16	没有指向对象的引用时，监视对象生命结束时的情形



### 弱引用

8.17	弱引用是可调用的对象，返回的是被引用的对象；如果所指对象不存在，返回None



### WeakValueDictionary简介

8.18	Chees有个kind属性和标准的字符串表示形式

8.19	你们店里到底有没有奶酪



### Python对不可变类型施加的把戏

8.20	使用另一个元组构建元组，得到的其实是同一个元组

8.21	字符串字面量可能会创建共享的对象



### 本章总结

is 和 ==的区别

简单的赋值不创建副本

+=和*=的增量赋值，左边的变量绑定的是不可变对象，会创建新的对象

函数的参数以别名形式传递，函数可能会修改通过参数传入的可变对象

使用可变类型作为函数参数的默认值可能会有危险





## 第九章：符合Python风格的对象

### 再谈向量类

9.1	Vector2d 实例的多种表示形式

9.2	目前定义的都是特殊方法



### 备选构造方法

9.3	frombytes 类方法



### classmethod与staticmethod

9.4	比较classmethod和staticmethod的行为



### 格式化显式

9.5	format第一版

9.6	format第二版，现在能计算极坐标



### 可散列的Vector2d

9.7	让Vector2d不可变的代码

9.8	实现hash方法

9.9	Vector2d 完整版



### Python的私有属性和“受保护的”属性

9.10	私有属性的名称会被“改写”，在前面加上下划线和类名



### 使用__slots__类属性节省空间

9.11	在Vector2d类中添加slots属性

9.12	使用slots以后的测试



### 覆盖类属性

9.13	设定从类中继承的typecode属性，自定义一个实例属性

9.14	ShortVector2d是Vector2d的子类，只用于覆盖typecode的默认值



### 本章总结

各种特殊方法

slots

实例属性和覆盖





## 第十章：序列的修改、散列和切片

### Vector类第一版

10.1	测试init和repr方法

10.2	第一个版本



### 协议和鸭子类型

10.3	示例1-1代码



### 切片原理

10.4	了解 getitem和切片行为

10.5	查看slice属性



### 能处理切片的getitem方法

10.6	添加len和getitem的方法

10.7	测试改进的getitem方法



### 动态存取属性

10.8	添加getattr方法

10.9	不恰当的行为：位v.x赋值没有抛出错误，但是前后矛盾

10.10	在Vector类中实现setattr方法



### Vector第四版

10.11	计算整数0~5的累计疑惑的三种方式

10.12	添加 hash方法

10.13	在eq方法在for循环中使用zip函数

10.14	用zip和all函数实现eq方法

10.15	zip内置函数的使用示例



### Vector第五版

10.16	全部代码



### 本章总结

通过getitem和len方法来实现vector的序列化

了解切片原理，并使用在vector上

getattr和setattr设置属性

hash和eq方法来实现散列





## 第十一章：接口：从协议到抽象基类

### Python文化中的接口和协议

11.1	x和y是公开属性

11.2	使用特性实现x和y



### Python喜欢序列

11.3	定义getitem方法，只实现序列协议的一部分，这样足够访问元素，迭代和使用in运算符了

11.4	实现序列协议的FrenchDeck类



### 使用猴子补丁在运行时实现协议

11.5	random.shuffle函数不能打乱FrenchDeck实例

11.6	为frenchdeck打猴子补丁，把它变成可变的，让random.shuffle函数能处理



### Alex Martelli的水禽

11.7	使用鸭子类型处理单个字符串或由字符串组成的可迭代对象



### 定义抽象基类的子类

11.8	franchdeck2 是collections.MutableSequence的子类



### 定义并使用一个抽象基类

11.9	Tombola是抽象基类，有两个抽象方法和两个具体方法

11.10	异常结构的部分层次结构

11.11	不符合Tombola要求的子类无法蒙混过关



### 定义Tombola抽象基类的子类

11.12	BingoCage是Tombola的具体子类

11.13	LotteryBlower是Tombola的具体子类，覆盖了继承的inspect和loaded方法



###  Tombola的虚拟子类

11.14	TomboList是Tombola的虚拟子类



### Tombola子类的测试方法

11.15	Tombola 子类的测试运行程序

11.16	Tombola子类的doctest



### 鹅的行为有可能像鸭子

11.17	Sized类的源码



### 本章总结

协议的高度动态本性

抽象基类的静态接口声明

虚拟子类

subclasshook

鸭子和白鹅的区别

抽象基类





## 继承的优缺点

###子类化内置类型很麻烦

12.1	内置类型dict的init和update方法会忽略我们覆盖的setitem方法

12.2	dict.update 方法会忽略AnswerDict.getitem方法

12.3	DoppelDict2 和 AnswerDict2能像预期那样使用，因为它们扩展的什UserDict，而不是Dict



### 多呈继承和方法解析顺序

12.4	ABC和D四个类

12.5	在D实例上调用

12.6	使用super()函数调用ping方法

12.7	使用super()函数调用ping方法

12.8	查看几个类的mro属性



### 本章总结

选择继承collections.abc的抽象基类而不是内置类型

mro类属性蕴藏的方法解析顺序





## 正确重载运算符

### 一元运算符

13.1	把一元运算符- 和+ 添加到Vector中



### x和+x何时不相等

13.2	算数运算上下文的精度变化可能导致x不等于+x

13.3	一元运算符+得到一个新Counter实例，但是没有零值和负值计数器



### 重载向量加法运算符+

13.4	Vector的add方法第一版

13.5	第一版add方法，也支持Vector之外的对象

13.6	如果左操作数是Vector之外的对象，第一版本的add方法无法处理

13.7	Vector的add和radd方法

13.8	add方法的操作数要是可迭代对象

13.9	add方法的操作数要是可迭代的数值对象

13.10	+运算方法添加到Vector



### 重载标量乘法运算符

13.11	增加*运算符方法



### 众多比较运算符

13.12	Vector实例与Vector实例，Vector2d实例和元组比较

13.13	改进vector的eq方法

13.14	与13_12一样的测试，最后一个结果变了



### 增量赋值运算符

13.15	增量赋值不会修改不可变目标，而是新建实例，然后重新绑定

13.16	使用+运算符新建addablebingocage实例

13.17	可以使用+=运算符载入现有的addablebingocage实例

13.18	addablebingocage 扩展 bingocage 支持+ 和+= 



### 本章总结

一元运算符

重载中缀运算符，鸭子类型或者isinstance测试

比较运算符

增量赋值运算符

