# 流畅的Python



## 第一章：Python数据模型

1.1	一摞Python风格的纸牌

1.2	一个简单的二维向量类 



### 本章总结：

介绍了一些特殊方法

getitem,len,contains,iter,repr,abs,add,mulstr,bool



## 第二章：序列构成的数组

### 列表推导和可读性

2.1	把一个字符串编程Unicode码位的列表

2.2	把一个字符串编程Unicode码位的列表（列表推导）

2.3	用列表推导和map/filter组合来创建同样表单

2.4	使用列表推导计算笛卡尔乘积

2.5	用生成器表达初始化元组和数组

2.6	使用生成器表达式计算笛卡尔积



### 元组

2.7	把元组用作记录

2.8	用嵌套元组来获取经度

2.9	定义和使用具名元组

2.10	具名元组的属性和方法



### 切片

2.11	纯文本文件形式的收据以一行字符串的形式被解析

2.12 	一个包含3个列表的列表，嵌套的3个列表各自有3个元素模仿一个井字游戏

2.13	含有3个指向同一对象的引用的列表毫无用处



### 序列的增量赋值

2.14	一个谜题

2.15	没人料到的结果：t[2]被改动，但也有异常

2.16	s[a] +=  b 背后的字节代码



### 用bisect来管理已排序的序列

2.17	在有序序列中使用bisect查找某个元素的插入位置

2.18	根据一个分数，找到它所对应的成绩

2.19	insort可以保持有序序列的顺序



### 数组

2.20	一个浮点型数组的创建、存入文件和从文件读取的过程

2.21	通过改变数组中的一个字节来更新数组里某个元素的值

2.22	对numpy.ndarray的行和列进行基本操作



### 双向队列和其他形式的队列

2.23	使用双向队列



### 本章总结：

序列可以分为可变和不可变，或者扁平序列和容器序列

列表推导和生成器

元组（拆包，*句法）

具名元组（._asdict()方法）

增量赋值

sort和sorted

bisect

array.array

numpy,scipy





## 第三章： 字典和集合

### 字典推导

3.1	字典推导的运用



### 常见的映射方法

3.2	从索引中获取单词出现的频率信息，并把它们写进对应的列表里

3.3	3_2.py的输出结果

3.4	用一行就解决了获取和更新单次的出现情况列表，用到了dict.setdefault



### 映射的弹性键查询

3.5	利用defaultdic实例而不是setdefault方法，创建一个从单次到其出现情况的映射

3.6	当有非字符串的键被查找的时候，如果在该键不存在的情况下，把它转换为字符串的

3.7	在查询的时候把非字符串的键转换为字符串



### 子类化UserDict

3.8	无论是添加、更新还是查询操作，StrKeyDict都会把非字符串的键转换为字符串



### 不可变映射类型

3.9	用MappingProxyType 来获取字典的只读实例mappingproxy



### 集合论

3.10	needles 的元素再haystack里出现的次数，两个变量都是set

3.11	needles的元素在haystack里出现的次数（迭代）

3.12	needles的元素在haystack里出现的次数（迭代），两个对象可以是任意迭代对象



### 集合推导

3.13	新建一个Latin-1字符集合，该集合里的每个字符的Unicode名字里都有"SIGN"这个单词



### 关于效率的实验

3.14	在haystack里用迭代的方法查找needles的元素，并计算找到的元素的个数

3.15	利用交集来计算needles中出现在haystack中的元素的个数



### 字典中的散列表

3.16	几个数字的散列值的二进制对比

3.17	将同样的数据以不同的顺序添加到3个字典里

3.18	3.17中输出的3个字典的结果顺序是不一样的



### 本章总结

标准库提供的一些映射类型

defaultdict,OrderDict,ChianMap,Count

两个强大方法：setdefault,update

通过__missing__来定义找不到对象时的操作

colletions.abc模块中提供Mapping 和 MutableMapping两个基类

types中MappingProxyType创建不可变映射对象

Set 和MutableSet 两个抽象基本类

dict和set的散列概念





## 第四章：文本和字节序列

### 字符问题

4.1	编码和解码



### 字节概要

4.2	包含5个字节的bytes和bytearray对象

4.3	使用数组中的原始数据初始化bytes对象

4.4	使用memoryview和struct查看一个GIF图像的首部



### 基本的编码器

4.5	使用3个编译器编码字符串"El Niño"，得到的字节序列差异很大



### 处理UnicodeEncodeError

4.6	编码成字节序列：成功和错误的处理



### 处理UnicodeDecodeError

4.7	把字节序列解码成字符串：成功和错误处理



### 使用预期之外的编码加载模块时抛出的SyntaxError

4.8	"你好，世界"的葡萄牙语版本



### 处理文本文件

4.9	一个平台上的编码问题（可能发生，也可能不发生）

4.10	细分析在windows中运行的示例4_9，找出并修正问题



### 编码默认值

4.11	探索编码的默认值

4.12	4_11在不同windows版本中的表现



### 规范化文本匹配使用函数

4.13	比较规范化Unicode 字符串



### 极端“规范化”

4_14	去掉全部组合记号的函数

4_15	4_14中函数的实例

4_16	删除拉丁字母中组合记号的函数

4_17	把一些西文印刷字符转换成ASCII字符

4_18	4_17中的实例



### Unicode文本排序

4.19	使用locale.strxfrm函数做排序键

4.20	使用pyuca.collator.sort_key方法



### Unicode数据库

4.21	Unicode数据库中数值字符的元数据示例



### 正则表达式中的字符串和字节序列

4.22	比较简单的字符串正则表达式和字节序列正则表达式的行为



### os函数中的字符串和字节序列

4.23	把字符串和字节序列参数传给listdir函数得到的结果

4.24	使用surrogateescape 错误处理方式



### 本章总结

区别字符和字节

bytes，bytearray，memoryview

Chardet包

设置合理的编码

locale来排序

PyUCA包
